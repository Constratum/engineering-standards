"""AS_4084_1_2023 Method

Automatically generated by Colaboratory.

This method references the following standard:
AS_4084_1_2023 Method, for Australian structures - Seismic Design of Storage Racking Systems.

Method developed 17 March 2025
(c) Constratum Ltd

Developed - NSh

Reviewed - MB

###Initialise  Dependents and Libraries
"""

import numpy as np
import pandas as pd


class StorageRackingSeismic:
    """
    Class for calculating seismic design parameters for storage racking systems according to
    AS 4084.1:2023 standard, sections 2.6 and 2.7.
    """

    def __init__(self, earthquake_design_category=None, site_hazard_factor=None):
        """
        Initialize the StorageRackingSeismic class.

        Args:
            earthquake_design_category (str): Earthquake design category
            site_hazard_factor (float): Site hazard factor
        """
        self.earthquake_design_category = earthquake_design_category
        self.site_hazard_factor = site_hazard_factor
        self.create_tables()

    def create_tables(self):
        """
        Create pandas DataFrames for the seismic design tables.
        """
        # Table 2.6.2 - Rigid mass factor (ΨM)
        self.create_rigid_mass_factor_table_2_6_2()

        # Table 2.6.6 - Drift modification factor
        self.create_drift_modification_factor_table_2_6_6()

        # Table 2.7.4 - Action factors
        self.create_action_factors_table_2_7_4()

    def create_rigid_mass_factor_table_2_6_2(self):
        """
        Create Table 2.6.2 - Rigid mass factor (ΨM).
        """
        table_data = {
            "Stored goods": [
                "Compact and constrained",
                "Weak",
                "Loose and unconstrained",
                "Liquid",
            ],
            "ΨM": [1.0, 0.8, 0.7, 1.0],
            "Example": [
                "Frozen goods (cold storage), Steel sheet package, Coils and paper rolls",
                "Large number of pieces stored on the pallet whose size is small in comparison to the pallet size, including goods stabilized by stretch wrapping",
                "Goods that can easily move around, inside the container (e.g., granulated materials)",
                "Unit load containing liquid that can slosh in the container",
            ],
        }

        self.df_rigid_mass_factor = pd.DataFrame(table_data)
        self.df_rigid_mass_factor.set_index("Stored goods", inplace=True)

    def create_drift_modification_factor_table_2_6_6(self):
        """
        Create Table 2.6.6 - Drift modification factor.
        """
        table_data = {
            "Structure height": ["h < 15 m", "15 ≤ h ≤ 30 m", "h > 30 m"],
            "Drift modification factor (kdm)": [1.2, "1.2 + 0.02(h - 15)", 1.5],
        }

        self.df_drift_modification = pd.DataFrame(table_data)
        self.df_drift_modification.set_index("Structure height", inplace=True)

    def create_action_factors_table_2_7_4(self):
        """
        Create Table 2.7.4 - Action factors (γ).
        """
        table_data = {
            "Actions": [
                "Permanent actions (γG)",
                "Variable actions (γQ)",
                "Accidental actions",
            ],
            "Ultimate limit state": [1.35, 1.4, 1.0],
            "Serviceability limit state": [1.0, 1.0, 1.0],
            "Notes": [
                "With unfavourable effect: 1.35, With favourable effect: 1.0",
                "Unit loads in Tolerance Grade I and II systems: 1.4, Unit loads in Tolerance Grade III systems: 1.4 or 1.3 (see Note), Other live actions: 1.4, Other live actions: 1.5",
                "See Appendix D",
            ],
        }

        self.df_action_factors = pd.DataFrame(table_data)
        self.df_action_factors.set_index("Actions", inplace=True)

    def get_rigid_mass_factor_2_6_2(self, stored_goods_type):
        """
        Get the rigid mass factor ΨM for a given type of stored goods.

        Args:
            stored_goods_type (str): Type of stored goods

        Returns:
            float: Rigid mass factor ΨM
        """
        try:
            return self.df_rigid_mass_factor.loc[stored_goods_type, "ΨM"]
        except KeyError:
            valid_types = self.df_rigid_mass_factor.index.tolist()
            raise ValueError(
                f"Invalid stored goods type: {stored_goods_type}. Valid types are: {valid_types}"
            )

    def get_seismic_mass_imposed_load_factor_2_6_2(self, stored_goods_type):
        """
        Get the seismic mass imposed load factor for a given direction.
        """
        psi_E = {"down-aisle": 0.85, "cross-aisle": 1.0}
        psi_M_value = self.get_rigid_mass_factor_2_6_2(stored_goods_type)
        psi_M = {"down-aisle": psi_M_value, "cross-aisle": psi_M_value}
        psi_A = {"down-aisle": 1.0, "cross-aisle": 1.0}
        return psi_E, psi_M, psi_A

    def get_seismic_mass_factor_2_6_2(self, direction, psi_E, psi_M, psi_A):
        """
        Get the seismic mass factor ΨM for a given type of stored goods.
        """
        G_factor = 1.0
        if direction == "down-aisle":
            seismic_weight = {
                "G": G_factor,
                "Q": float(psi_M[direction] * psi_E[direction] * psi_A[direction]),
            }
        elif direction == "cross-aisle":
            seismic_weight = {
                "G": G_factor,
                "Q": float(psi_M[direction] * psi_E[direction] * psi_A[direction]),
            }
        else:
            raise ValueError(
                f"Invalid direction: {direction}. Valid directions are: down-aisle, cross-aisle"
            )
        return seismic_weight

    def calculate_seismic_mass_2_6_2(self, G, Q_u, Q_f, psi_E, psi_M, psi_A):
        """
        Calculate the seismic mass (Wt) according to Clause 2.6.2.

        Formula: Wt = G + ΨA ΨE ΨM Qu + 0.3Qf

        Args:
            G (float): Permanent actions (dead loads) in N
            psi_A (float): Specified average unit load factor for the upright frame or global down-aisle design
            psi_E (float): Specified storage occupancy factor
            psi_M (float): Rigid mass factor accounting for energy dissipation within the unit loads
            Q_u (float): Maximum imposed unit load action from stored goods in N
            Q_f (float): Imposed live load action on any floors supported by the rack in N

        Returns:
            float: Seismic mass (Wt) in N
        """

        Wt_down_aisle = (
            G
            + psi_A["down-aisle"] * psi_E["down-aisle"] * psi_M["down-aisle"] * Q_u
            + 0.3 * Q_f
        )
        Wt_cross_aisle = (
            G
            + psi_A["cross-aisle"] * psi_E["cross-aisle"] * psi_M["cross-aisle"] * Q_u
            + 0.3 * Q_f
        )
        return Wt_down_aisle, Wt_cross_aisle

    def get_ductility_factor_2_6_3(self):
        """
        Get the ductility factor μ for storage racking.
        """
        mu = {"down-aisle": 1.5, "cross-aisle": 1.5}
        return mu

    def get_drift_modification_factor_2_6_6(self, structure_height):
        """
        Calculate the drift modification factor kdm based on structure height.

        Args:
            structure_height (float): Height of the structure in meters

        Returns:
            float: Drift modification factor kdm
        """
        if structure_height < 15:
            return 1.2
        elif 15 <= structure_height <= 30:
            return 1.2 + 0.02 * (structure_height - 15)
        else:  # h > 30
            return 1.5

    def calculate_seismic_mass_with_restriction(self, G, psi_A, psi_E, psi_M, Q_u, Q_f):
        """
        Calculate the seismic mass (Wt) with the restriction that ΨE ΨM ≥ 0.6.

        Args:
            G (float): Permanent actions (dead loads) in N
            psi_A (float): Specified average unit load factor for the upright frame or global down-aisle design
            psi_E (float): Specified storage occupancy factor
            psi_M (float): Rigid mass factor accounting for energy dissipation within the unit loads
            Q_u (float): Maximum imposed unit load action from stored goods in N
            Q_f (float): Imposed live load action on any floors supported by the rack in N

        Returns:
            tuple: (Wt, effective_psi_E_psi_M) where Wt is the seismic mass and effective_psi_E_psi_M is the adjusted factor
        """
        # Apply the restriction ΨE ΨM ≥ 0.6
        effective_psi_E_psi_M = max(psi_E * psi_M, 0.6)

        Wt = G + psi_A * effective_psi_E_psi_M * Q_u + 0.3 * Q_f

        return Wt, effective_psi_E_psi_M

    def check_maximum_drift_2_6_6(self, delta_eu, mu, h):
        """
        Calculate the maximum allowable drift under ultimate earthquake loads.

        Formula: δdr = δeu μ kdm < 0.05h

        Args:
            delta_eu (float): Ultimate elastic displacement of the rack using either LA or GNA in mm
            mu (float): Ductility factor
            k_dm (float): Drift modification factor
            h (float): Total height of the upright frame in mm

        Returns:
            tuple: (delta_dr, is_acceptable) where delta_dr is the drift and is_acceptable is whether it meets the limit
        """
        k_dm = self.get_drift_modification_factor_2_6_6(h)
        delta_dr = delta_eu * mu * k_dm
        limit = 0.05 * h
        is_acceptable = delta_dr < limit

        return bool(is_acceptable), float(delta_dr)

    def get_structural_performance_factor(self, design_standard):
        """
        Get the structural performance factor Sp based on the design standard.

        Args:
            design_standard (str): Design standard ('AS_1170.4' or 'AS_1170.5')

        Returns:
            float: Structural performance factor Sp
        """
        if design_standard == "AS_1170.4":
            return 1.0
        elif design_standard == "AS_1170.5":
            return 1.3 - 0.3  # This would need to be calculated based on Mu
        else:
            raise ValueError("Design standard must be 'AS_1170.4' or 'AS_1170.5'")

    def calculate_action_combination_ultimate_most_unfavourable(
        self, gamma_G, G, gamma_Q, Q_1
    ):
        """
        Calculate action combination for ultimate limit states - most unfavourable variable action.

        Formula: ΣγG G + γQ Q1

        Args:
            gamma_G (float): Partial factor for permanent actions
            G (float): Permanent actions
            gamma_Q (float): Partial factor for variable actions
            Q_1 (float): Most unfavourable variable action

        Returns:
            float: Combined action
        """
        return gamma_G * G + gamma_Q * Q_1

    def calculate_action_combination_ultimate_all_unfavourable(
        self, gamma_G, G, gamma_Q, Q_1, psi_s=0.9
    ):
        """
        Calculate action combination for ultimate limit states - all unfavourable variable actions.

        Formula: ΣγG G + 0.9 Σ γQ Q1

        Args:
            gamma_G (float): Partial factor for permanent actions
            G (float): Permanent actions
            gamma_Q (float): Partial factor for variable actions
            Q_1 (float): Variable actions
            psi_s (float): Combination factor (default 0.9)

        Returns:
            float: Combined action
        """
        return gamma_G * G + psi_s * gamma_Q * Q_1

    def calculate_action_combination_accidental(
        self, gamma_GA, G, gamma_QA, Q_1, gamma_A, A
    ):
        """
        Calculate action combination for accidental actions.

        Formula: ΣγGA G + Σ γQA Q1 + γA A

        Args:
            gamma_GA (float): Partial factor for permanent actions under accidental ultimate limit states
            G (float): Permanent actions
            gamma_QA (float): Partial factor for variable actions under accidental ultimate limit states
            Q_1 (float): Variable actions
            gamma_A (float): Partial factor for accidental actions
            A (float): Accidental actions

        Returns:
            float: Combined action
        """
        return gamma_GA * G + gamma_QA * Q_1 + gamma_A * A

    def calculate_action_combination_seismic(self, G, psi_A, psi_E, Q_u, Q_f, E_u):
        """
        Calculate action combination for seismic actions.

        Formula: G + ΨA ΨE Qu + 0.3Qf + Eu

        Args:
            G (float): Permanent actions
            psi_A (float): Average unit load factor
            psi_E (float): Storage occupancy factor
            Q_u (float): Maximum imposed unit load action
            Q_f (float): Live load action on floors
            E_u (float): Ultimate limit state earthquake load

        Returns:
            float: Combined action for seismic design
        """
        return G + psi_A * psi_E * Q_u + 0.3 * Q_f + E_u

    def calculate_action_combination_wind(self, G, psi_A, psi_E, Q_u, Q_f, W_u):
        """
        Calculate action combination for wind actions.

        Formula: 1.3G + ΨA ΨE Qu + 0.6Qf + Wu
                 0.9G + Wu

        Args:
            G (float): Permanent actions
            psi_A (float): Average unit load factor
            psi_E (float): Storage occupancy factor
            Q_u (float): Maximum imposed unit load action
            Q_f (float): Live load action on floors
            W_u (float): Ultimate limit state wind load

        Returns:
            tuple: (combination_1, combination_2) where both combinations should be checked
        """
        combination_1 = 1.3 * G + psi_A * psi_E * Q_u + 0.6 * Q_f + W_u
        combination_2 = 0.9 * G + W_u

        return combination_1, combination_2

    def get_serviceability_combination_most_unfavourable(
        self, gamma_G, G, gamma_Q, Q_1
    ):
        """
        Calculate action combination for serviceability limit states - most unfavourable variable action.

        Formula: ΣγG G + γQ Q1

        Args:
            gamma_G (float): Partial factor for permanent actions (typically 1.0)
            G (float): Permanent actions
            gamma_Q (float): Partial factor for variable actions (typically 1.0)
            Q_1 (float): Most unfavourable variable action

        Returns:
            float: Combined action
        """
        return gamma_G * G + gamma_Q * Q_1

    def calculate_serviceability_combination_all_unfavourable(
        self, gamma_G, G, gamma_Q, Q_1, psi_s=0.9
    ):
        """
        Calculate action combination for serviceability limit states - all unfavourable variable actions.

        Formula: ΣγG G + 0.9 Σ γQ Q1

        Args:
            gamma_G (float): Partial factor for permanent actions (typically 1.0)
            G (float): Permanent actions
            gamma_Q (float): Partial factor for variable actions (typically 1.0)
            Q_1 (float): Variable actions
            psi_s (float): Combination factor (default 0.9)

        Returns:
            float: Combined action
        """
        return gamma_G * G + psi_s * gamma_Q * Q_1

    def get_serviceability_limit_state_load_combinations_2_7_3(
        self,
    ):
        """Return serviceability limit state (SLS) load combinations per Clause 2.7.3.

        Args:
            psi_E (dict): Storage occupancy factors by direction, e.g. {"down-aisle": 0.85, "cross-aisle": 1.0}
            psi_M (dict): Rigid mass factors by direction
            psi_A (dict): Average unit load factors by direction

        Returns:
            list[dict]: Recommended serviceability load combinations in simple factor format.
        """
        # Action factors at SLS per Table 2.7.4
        gamma_G_sls = self.get_action_factors(
            "Permanent actions (γG)", "Serviceability limit state"
        )
        gamma_Q_sls = self.get_action_factors(
            "Variable actions (γQ)", "Serviceability limit state"
        )

        load_combos_sls = [
            # Gravity SLS
            {"Serviceability": {"G": float(gamma_G_sls), "Q": float(gamma_Q_sls)}}
        ]

        return load_combos_sls

    def calculate_serviceability_combination_wind(self, G, psi_A, psi_E, Q_u, W_s):
        """
        Calculate action combination for serviceability limit states with wind.

        Formula: G + ΨA ΨE Qu + Ws

        Args:
            G (float): Permanent actions
            psi_A (float): Average unit load factor
            psi_E (float): Storage occupancy factor
            Q_u (float): Maximum imposed unit load action
            W_s (float): Serviceability limit state wind load

        Returns:
            float: Combined action
        """
        return G + psi_A * psi_E * Q_u + W_s

    def check_minimum_separation_distance(self, delta_dr, building_drift=0):
        """
        Check if the minimum separation distance between rack and building structure is satisfied.

        The minimum separation distance should be greater than the maximum drift of the rack (δdr)
        limited to 0.05h plus allowance for any drift deflections of the adjacent building structure.

        Args:
            delta_dr (float): Maximum drift of the rack in mm
            building_drift (float): Drift deflections of the adjacent building structure in mm

        Returns:
            float: Minimum required separation distance in mm
        """
        return delta_dr + building_drift

    def analyze_down_aisle_direction(self, seismic_mass, uplift_percentage=0.3):
        """
        Analyze seismic actions in the down-aisle direction.

        For vertical bracing subsystems not located at end bays and supporting storage loads,
        the uprights shall be subjected to maximum of 30% of their average storage load for uplift checking.

        Args:
            seismic_mass (float): Seismic mass calculated from clause 2.6.2
            uplift_percentage (float): Percentage of average storage load for uplift checking (default 0.3)

        Returns:
            dict: Analysis results including uplift forces and design considerations
        """
        analysis_results = {
            "seismic_mass": seismic_mass,
            "uplift_percentage": uplift_percentage,
            "uplift_force_factor": uplift_percentage,
            "note": "Global analysis with fully loaded rack using seismic mass from Clause 2.6.2",
            "additional_check": "Mass distributions that maximize internal forces in each element should be considered",
        }

        return analysis_results

    def get_action_factors(self, action_type, limit_state):
        """
        Get action factors from Table 2.7.4.

        Args:
            action_type (str): Type of action ('Permanent actions (γG)', 'Variable actions (γQ)', 'Accidental actions')
            limit_state (str): Limit state ('Ultimate limit state' or 'Serviceability limit state')

        Returns:
            float: Action factor
        """
        try:
            return self.df_action_factors.loc[action_type, limit_state]
        except KeyError:
            valid_actions = self.df_action_factors.index.tolist()
            valid_states = self.df_action_factors.columns.tolist()
            raise ValueError(
                f"Invalid action_type: {action_type} or limit_state: {limit_state}. "
                f"Valid actions: {valid_actions}, Valid states: {valid_states}"
            )

    def design_for_imposed_stored_materials(self, stored_materials_criteria):
        """
        Design considerations for imposed actions from stored materials.

        The worst load (action) pattern shall be taken into account for each of the following criteria:
        (a) Overall stability in the down-aisle direction
        (b) Bending and buckling of the uprights
        (c) Beam deflections and mid-span bending moments
        (d) Moments in beam to upright connections

        Args:
            stored_materials_criteria (dict): Dictionary containing design criteria and loads

        Returns:
            dict: Design recommendations for each criterion
        """
        design_recommendations = {
            "overall_stability": {
                "description": "Overall stability in the down-aisle direction",
                "consideration": "Fully loaded structure with actions from imperfections as specified in Clause 3.3.2",
            },
            "upright_bending_buckling": {
                "description": "Bending and buckling of the uprights",
                "consideration": "Consider worst-case loading patterns for maximum upright stresses",
            },
            "beam_deflections": {
                "description": "Beam deflections and mid-span bending moments",
                "consideration": "Analyze for maximum beam moments and deflections",
            },
            "connection_moments": {
                "description": "Moments in beam to upright connections",
                "consideration": "Design connections for maximum moments from various loading patterns",
            },
        }

        return design_recommendations

    def get_ultimate_limit_state_load_combinations_2_7_2(self, psi_E, psi_M, psi_A):
        """
        Get load combinations according to AS 4084.1:2023 Clause 2.7.2 for ultimate limit states.
        Returns combinations (a) and (d) in simple format.
        """
        # Calculate combined seismic factors for both directions
        seismic_factor_down_aisle = (
            psi_A["down-aisle"] * psi_E["down-aisle"] * psi_M["down-aisle"]
        )
        seismic_factor_cross_aisle = (
            psi_A["cross-aisle"] * psi_E["cross-aisle"] * psi_M["cross-aisle"]
        )

        load_combos = [
            {"Gravity": {"G": 1.3, "Q": 1.4}},
            {
                "Seismic_down_aisle": {
                    "G": 1.0,
                    "Q": float(seismic_factor_down_aisle),
                    "Eu_down_aisle": 1.0,
                }
            },
            {
                "Seismic_cross_aisle": {
                    "G": 1.0,
                    "Q": float(seismic_factor_cross_aisle),
                    "Eu_cross_aisle": 1.0,
                }
            },
        ]

        return load_combos

    def check_beam_deflection_4_2_5(self, deflection, beam_span):
        """
        Check if the beam deflection is within the limit.
        """
        limit = beam_span / 180
        is_acceptable = deflection < limit
        ratio = deflection / limit
        return bool(is_acceptable), float(ratio)


class SeismicRackingAnalysis:
    """
    Comprehensive seismic analysis class for storage racking systems.
    """

    def __init__(self, racking_system):
        """
        Initialize with a StorageRackingSeismic instance.

        Args:
            racking_system (StorageRackingSeismic): Instance of StorageRackingSeismic
        """
        self.racking_system = racking_system

    def perform_complete_seismic_analysis(self, analysis_parameters):
        """
        Perform a complete seismic analysis of the storage racking system.

        Args:
            analysis_parameters (dict): Dictionary containing all analysis parameters

        Returns:
            dict: Complete analysis results
        """
        results = {}

        # Calculate seismic mass
        seismic_mass = self.racking_system.calculate_seismic_mass_with_restriction(
            analysis_parameters["G"],
            analysis_parameters["psi_A"],
            analysis_parameters["psi_E"],
            analysis_parameters["psi_M"],
            analysis_parameters["Q_u"],
            analysis_parameters["Q_f"],
        )
        results["seismic_mass"] = seismic_mass

        # Calculate drift
        drift_results = self.racking_system.calculate_maximum_drift(
            analysis_parameters["delta_eu"],
            analysis_parameters["mu"],
            analysis_parameters["k_dm"],
            analysis_parameters["h"],
        )
        results["drift_analysis"] = drift_results

        # Action combinations
        results["action_combinations"] = self._calculate_all_action_combinations(
            analysis_parameters
        )

        # Down-aisle analysis
        results["down_aisle_analysis"] = (
            self.racking_system.analyze_down_aisle_direction(seismic_mass[0])
        )

        return results

    def _calculate_all_action_combinations(self, params):
        """
        Calculate all relevant action combinations.

        Args:
            params (dict): Analysis parameters

        Returns:
            dict: All action combination results
        """
        combinations = {}

        # Ultimate limit state combinations
        combinations["ultimate_most_unfavourable"] = (
            self.racking_system.calculate_action_combination_ultimate_most_unfavourable(
                params["gamma_G"], params["G"], params["gamma_Q"], params["Q_1"]
            )
        )

        combinations["ultimate_all_unfavourable"] = (
            self.racking_system.calculate_action_combination_ultimate_all_unfavourable(
                params["gamma_G"], params["G"], params["gamma_Q"], params["Q_1"]
            )
        )

        # Seismic combination
        combinations["seismic"] = (
            self.racking_system.calculate_action_combination_seismic(
                params["G"],
                params["psi_A"],
                params["psi_E"],
                params["Q_u"],
                params["Q_f"],
                params["E_u"],
            )
        )

        # Wind combinations
        combinations["wind"] = self.racking_system.calculate_action_combination_wind(
            params["G"],
            params["psi_A"],
            params["psi_E"],
            params["Q_u"],
            params["Q_f"],
            params["W_u"],
        )

        return combinations


# Factory function to create seismic analysis system
def create_seismic_analysis_system(
    earthquake_design_category=None, site_hazard_factor=None
):
    """
    Factory function to create a complete seismic analysis system.

    Args:
        earthquake_design_category (str): Earthquake design category
        site_hazard_factor (float): Site hazard factor

    Returns:
        tuple: (StorageRackingSeismic instance, SeismicRackingAnalysis instance)
    """
    racking_system = StorageRackingSeismic(
        earthquake_design_category, site_hazard_factor
    )
    analysis_system = SeismicRackingAnalysis(racking_system)

    return racking_system, analysis_system
